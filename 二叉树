/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

// 往完全二叉树添加节点
// 完全二叉树是每一层（除最后一层外）都是完全填充（节点数达到最大，第 n 层有 2^(n-1) 个节点）的
// 并且所有的节点都尽可能地集中在左侧
// CBTInserter(TreeNode root) 使用根节点为 root 的给定树初始化该数据结构
// CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v
// 使树保持完全二叉树的状态，并返回插入的新节点的父节点的值
// CBTInserter.get_root() 将返回树的根节点
class CBTInserter {
    TreeNode r;
    Queue<TreeNode> q = new LinkedList<>(); // 保存左右子树都空的结点
    public CBTInserter(TreeNode root) {
        Queue<TreeNode> qq = new LinkedList<>();
        r = root;
        qq.offer(root);
        while(!qq.isEmpty()) {
            TreeNode t = qq.poll();
            if(t.left == null || t.right == null) { // 保存左右子树都空的结点
                q.offer(t);
            }
            if(t.left != null) { // 先查左子树
                qq.offer(t.left);
            }
            if(t.right != null) { // 后查右子树
                qq.offer(t.right);
            }
        }
    }
    public int insert(int v) {
        TreeNode t = q.peek(); // 获取当前有空的结点
        if(t.left == null) {
            t.left = new TreeNode(v);
            q.offer(t.left); // 尾部加入新插入的结点
        } else {
            t.right = new TreeNode(v);
            q.poll(); // 右侧也加入了结点，因此从有空的节点中删除
            q.offer(t.right);
        }
        return t.val;
    }
    public TreeNode get_root() {
        return r;
    }
}

// 二叉树每层的最大值
// 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值
// root = [1,3,2,5,3,null,9] => [1,3,9]
//          1
//         / \
//        3   2
//       / \   \  
//      5   3   9
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        int max, len;
        Queue<TreeNode> q = new LinkedList<>();
        if(root != null) {
            q.offer(root);
        }
        while(!q.isEmpty()) { // BFS 广度优先搜索
            len = q.size();
            max = Integer.MIN_VALUE;
            for(int i = 0; i < len; i++) {
                TreeNode t = q.poll();
                max = Math.max(max, t.val);
                if(t.left != null) {
                    q.offer(t.left);
                }
                if(t.right != null) {
                    q.offer(t.right);
                }
            }
            res.add(max);
        }
        return res;
    }
}

//
